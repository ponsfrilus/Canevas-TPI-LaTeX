\chapter{Réalisation}
\section{Dossier de réalisation}
Décrire la réalisation "physique" de votre projet
\begin{itemize}
  \item les répertoires où le logiciel est installé
  \item la liste de tous les fichiers et une rapide description de leur contenu (des noms qui parlent !)
  \item les versions des systèmes d'exploitation et des outils logiciels
  \item la description exacte du matériel
  \item le numéro de version de votre produit !
  \item programmation et scripts: librairies externes, dictionnaire des données, reconstruction du logiciel - cible à partir des sources.
\end{itemize}
NOTE : Evitez d’inclure les listings des sources, à moins que vous ne désiriez en expliquer une partie vous paraissant importante. Dans ce cas n’incluez que cette partie…

\section{Description des tests effectués}
Pour chaque partie testée de votre projet, il faut décrire:
\begin{itemize}
  \item les conditions exactes de chaque test
  \item les preuves de test (papier ou fichier)
  \item tests sans preuve: fournir au moins une description 
\end{itemize}

\section{Erreurs restantes}
S'il reste encore des erreurs: 
\begin{itemize}
  \item Description détaillée
  \item Conséquences sur l'utilisation du produit
  \item Actions envisagées ou possibles
\end{itemize}

\section{Liste des documents fournis}
Lister les documents fournis au client avec votre produit, en indiquant les numéros de versions 
\begin{itemize}
  \item le rapport de projet
  \item le manuel d'Installation (en annexe)
  \item le manuel d'Utilisation avec des exemples graphiques (en annexe)
  \item autres…
\end{itemize}

\section{Exemples d'extrait de code}

\subsection{Python}
\begin{minted}[linenos]{python}
import numpy as np

def incmatrix(genl1,genl2):
    m = len(genl1)
    n = len(genl2)
    M = None #to become the incidence matrix
    VT = np.zeros((n*m,1), int)  #dummy variable

    #compute the bitwise xor matrix
    M1 = bitxormatrix(genl1)
    M2 = np.triu(bitxormatrix(genl2),1) 

    for i in range(m-1):
        for j in range(i+1, m):
            [r,c] = np.where(M2 == M1[i,j])
            for k in range(len(r)):
                VT[(i)*n + r[k]] = 1;
                VT[(i)*n + c[k]] = 1;
                VT[(j)*n + r[k]] = 1;
                VT[(j)*n + c[k]] = 1;
                    
                if M is None:
                    M = np.copy(VT)
                else:
                    M = np.concatenate((M, VT), 1)
                
                VT = np.zeros((n*m,1), int)
    
    return M
\end{minted}

\subsection{cpp with linenos}
\begin{minted}[linenos]{cpp}
#include <cstdio>
#include <cstdlib>
#include <iostream>

using namespace std;

unsigned short i;

int main() {
  for (i = 0; i <= 5; i++) {
    // whatever
  }
  return 0;
}
\end{minted}

\subsection{cpp with margin and linenos}
\begin{minted}[xleftmargin=1em,linenos]{cpp}
#include <cstdio>
#include <cstdlib>
#include <iostream>

using namespace std;

unsigned short i;

int main() {
  for (i = 0; i <= 5; i++) {
    // whatever
  }
  return 0;
}
\end{minted}
